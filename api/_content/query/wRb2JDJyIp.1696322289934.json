{"_path":"/topics/robotics/nmpc-cgmres","_dir":"robotics","_draft":false,"_partial":false,"_locale":"","_empty":false,"title":"Nonlinear Model Predictive Control with C/GMRES","description":"Optimal Control theory","author":"Din Sokheng","slug":"nmpc-cgmres","tag":"nmpc-cgmres","img":"/topics/robotics/nmpc/nmpc-cgmres.png","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"the-optimal-control-theory-in-control-system"},"children":[{"type":"text","value":"The Optimal Control Theory in Control System"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Optimal Control is a branch of control theory in control system, the theory works by solving the optimization problem of the dynamical system in order to find the optimal solution for the system"}]},{"type":"element","tag":"h3","props":{"id":"what-is-model-predictive-control"},"children":[{"type":"text","value":"What is Model Predictive Control ?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Model Predictive Control (MPC) is the optimal control method that use optimization algorithms to solve the cost function the occurs from the desired input and obtain back the optimal input control over the finite and infinite horizons. Recently, MPC is hyping up among the control system researcher, since it is fast, efficiency and robustness for any high complex system."}]},{"type":"element","tag":"h3","props":{"id":"hamilton-jacobian-bellman-equation-hjbe"},"children":[{"type":"text","value":"Hamilton Jacobian Bellman Equation (HJBE)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Actually, the HJBE is a nonlinear partial differential equation that it consists necessary conditions for optimality of control by minimizing the loss function of the system. "},{"type":"element","tag":"br","props":{},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We have the Hamiltonian Jacobian Bellman Equation"}]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{equation}\n    H(x,u,\\lambda,\\mu) = \\sum_{k=0}^{N-1}(x_{k}-x_{k,ref})^{T} Q(x_{k}-x_{k,ref}) + (u_{k}-u_{k,ref})^{T}R(u_{k}-u_{k,ref}) + \n                         \\phi(x) + \\lambda^{T}f(x,u) + \\mu^{T}C(x,u)\n\\end{equation}","styles":"text-center"},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Which"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"N","styles":"inline-flex"},"children":[]},{"type":"text","value":" is the number of prediction future horizons or shooting node."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"x_{k}","styles":"inline-flex"},"children":[]},{"type":"text","value":" is the state of the system at shooting node "},{"type":"element","tag":"math-render","props":{"latex-express":"k","styles":"inline-flex"},"children":[]},{"type":"text","value":" ."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"u_{k}","styles":"inline-flex"},"children":[]},{"type":"text","value":" is the input control of the system at shooting node "},{"type":"element","tag":"math-render","props":{"latex-express":"k","styles":"inline-flex"},"children":[]},{"type":"text","value":" ."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"Q, R","styles":"inline-flex"},"children":[]},{"type":"text","value":" are diagonal matrix which helps the optimization solving the nlp problem."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"f(x,u)","styles":"inline-flex"},"children":[]},{"type":"text","value":" is the state representation of the system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"C(x,u)","styles":"inline-flex"},"children":[]},{"type":"text","value":"  is the constraint of the system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"\\lambda","styles":"inline-flex"},"children":[]},{"type":"text","value":"  is the costate vector for state representation."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"\\mu","styles":"inline-flex"},"children":[]},{"type":"text","value":"  is the costate vector for the input control."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Nonlinear Model Predictive Control has multiples solving method, but in this demonstration I will stick with the Continuation/GMRES method proposed by professor "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":" Toshiyuki Ohtsuka "}]},{"type":"text","value":". "},{"type":"element","tag":"br","props":{},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Supposed we want to obtain input control "},{"type":"element","tag":"math-render","props":{"latex-express":"U(t) = [ u_{0}^{*}, \\cdots, u_{N-1}^{*} ]","styles":"inline-flex"},"children":[]},{"type":"text","value":"   at sampling time $t$, we then define the discretization of "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":" Euler Lagrangian Equation (ELE) "}]},{"type":"text","value":"."}]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{align}\n    x_{i+1}^{*}(t) &= x_{i}^{*}(t) + f(x_{i}^{*}(t), u_{i}^{*}(t))  \\\\\n    \\lambda_{i}^{*}(t) &= \\lambda_{i+1}^{*}(t) + \\frac{\\partial H}{\\partial x}\\left( x_{i}^{*}, u_{i}^{*}(t), \\lambda_{i+1}^{*}(t), \\mu_{i}^{*}(t) \\right) \\\\\n    \\lambda_{N}^{*}(t) &= \\frac{\\partial \\phi(x)}{\\partial x} \\\\\n    \\frac{\\partial H}{\\partial u} &\\left( x_{i}^{*}, u_{i}^{*}(t), \\lambda_{i+1}^{*}(t), \\mu_{i}^{*}(t) \\right) = 0 \\\\\n    C&(x_{i}^{*}(t),u_{i}^{*}(t)) = 0\n\\end{align}\n","style":"text-ceneter"},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To solve this nonlinear problem iteratively, we use Newton's method "},{"type":"element","tag":"math-render","props":{"latex-express":"F(x,u)=0","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{equation}\n    F(x,u) = \\begin{bmatrix}\n        \\frac{\\partial H}{\\partial u} \\left( x_{0}^{*}, u_{0}^{*}(t), \\lambda_{1}^{*}(t), \\mu_{0}^{*}(t) \\right) \\\\\n        C(x_{0}^{*}(t),u_{0}^{*}(t))  \\\\\n        \\vdots \\\\\n        \\frac{\\partial H}{\\partial u} \\left( x_{N-1}^{*}, u_{N-1}^{*}(t), \\lambda_{N}^{*}(t), \\mu_{N-1}^{*}(t) \\right) \\\\\n        C(x_{N-1}^{*}(t),u_{N-1}^{*}(t)) \\\\\n    \\end{bmatrix} = 0\n\\end{equation}","styles":"text-center"},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Solving this problem directly will caused big computational complexity, hence we use Continuation to reduce the complexity of the "},{"type":"element","tag":"math-render","props":{"latex-express":"F(x,u)","styles":"inline-flex"},"children":[]},{"type":"text","value":" function and then solve it by using GMRES method."}]},{"type":"element","tag":"h3","props":{"id":"continuation"},"children":[{"type":"text","value":"Continuation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Denote  "},{"type":"element","tag":"math-render","props":{"latex-express":"\\zeta, \\alpha, h \\in{\\mathbb{R} }","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{equation*}\n    \\frac{\\partial F}{\\partial u}(x,u) \\dot{u}(t) = -\\zeta F(x,u)(t)-\\frac{\\partial F}{\\partial x}(x,u)(t)\\dot{x}-\\frac{\\partial F}{\\partial t}(x,u)(t) \n\\end{equation*}","styles":"text-center"},"children":[]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{equation*}\n    \\frac{F(x(t)+h\\dot{x}(t),u(t)+h\\dot{u}(t),t+h)-F(x+h\\dot{x}(t),u(t),t+h)}{h} = -\\zeta F(x(t),u(t), t) - \\frac{F(x+h\\dot{x}(t), u(t),t+h)-F(x(t), u(t), t)}{h}\n\\end{equation*}","styles":"text-center"},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Let "},{"type":"element","tag":"math-render-b","props":{"latex-express":"right=\\frac{F(x(t)+h\\dot{x}(t),u(t)+h\\dot{u}(t),t+h)-F(x+h\\dot{x}(t),u(t),t+h)}{h}","styles":"text-center"},"children":[]},{"type":"text","value":" and "},{"type":"element","tag":"math-render-b","props":{"latex-express":"left =  -\\zeta F(x(t),u(t), t) - \\frac{F(x+h\\dot{x}(t), u(t),t+h)-F(x(t), u(t), t)}{h}","styles":"text-center"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"generalized-minimal-residue-method-gmres"},"children":[{"type":"text","value":"Generalized Minimal Residue Method (GMRES)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Generalized Minimal Residual (GMRES) algorithm is an iterative method for solving linear systems of equations. It is often used for large sparse linear systems."}]},{"type":"element","tag":"h4","props":{"id":"algorithm-description"},"children":[{"type":"text","value":"Algorithm Description"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Initialize"}]},{"type":"text","value":":"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Choose an initial guess for the solution, denoted as "},{"type":"element","tag":"math-render","props":{"latex-express":"x_{0}","styles":"inline-flex"},"children":[]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Set the residual vector "},{"type":"element","tag":"math-render","props":{"latex-express":"r_{0}=\\left\\| Ax_{0}-b \\right\\|","styles":"inline-flex"},"children":[]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Set "},{"type":"element","tag":"math-render","props":{"latex-express":"v_{1}=\\frac{r_{0} }{\\left\\| r_{0} \\right\\|}","styles":"inline-flex"},"children":[]},{"type":"text","value":", where "},{"type":"element","tag":"math-render","props":{"latex-express":"\\left\\| r_{0} \\right\\|","styles":"inline-flex"},"children":[]},{"type":"text","value":"  is the norm of "},{"type":"element","tag":"math-render","props":{"latex-express":"r_{0}","styles":"inline-flex"},"children":[]},{"type":"text","value":"."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Iterative Process"}]},{"type":"text","value":":"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Choose a vector "},{"type":"element","tag":"math-render","props":{"latex-express":"v_{1}","styles":"inline-flex"},"children":[]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For "},{"type":"element","tag":"math-render","props":{"latex-express":"k=0","styles":"inline-flex"},"children":[]},{"type":"text","value":" to "},{"type":"element","tag":"math-render","props":{"latex-express":"maxiteration","styles":"inline-flex"},"children":[]},{"type":"text","value":":"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Arnoldi process:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"h_{i,j} = \\left(Av_{j}, v_{i} \\right)","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"\\hat{v}_{j+1} = Av_{j} - \\sum_{i=1}^{j}h_{i,j}v_{i}","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"h_{j+1,j} = \\left \\| \\hat{v}_{j+1}  \\right\\|_{2}","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"v_{j+1} = \\frac{\\hat{v}_{j+1} }{h_{j+1,j} }","styles":"inline-flex"},"children":[]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Check for convergence:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"If "},{"type":"element","tag":"math-render","props":{"latex-express":"||r_k|| < tolerance","styles":"inline-flex"},"children":[]},{"type":"text","value":", exit the loop."}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"If no convergence is achieved after "},{"type":"element","tag":"math-render","props":{"latex-express":"maxiterations","styles":"inline-flex"},"children":[]},{"type":"text","value":", exit with an error message."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Find "},{"type":"element","tag":"math-render","props":{"latex-express":"y","styles":"inline-flex"},"children":[]}]},{"type":"text","value":": which minimize "},{"type":"element","tag":"math-render","props":{"latex-express":"\\left\\| r_{0}e_{1}-\\hat{H}_{m}y \\right \\|_{2}","styles":"inline-flex"},"children":[]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Compute"}]},{"type":"text","value":": "},{"type":"element","tag":"math-render","props":{"latex-express":"x_{m} = x_{0}+V_{m}y_{m}","styles":"inline-flex"},"children":[]},{"type":"text","value":"."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For example differential model, let "},{"type":"element","tag":"math-render","props":{"latex-express":"x, y, \\phi","styles":"inline-flex"},"children":[]},{"type":"text","value":" is the state presentation of the model\n$$ \\dot{x} = f(x,u) $$"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Then the HJBE defined as"}]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{equation}\n    H(x,u,\\lambda,\\mu) = \\sum_{k=0}^{N-1}(x_{k}-x_{k,ref})^{T}Q(x_{k}-x_{k,ref}) + (u_{k}-u_{k,ref})^{T}R(u_{k}-u_{k,ref}) + \n                         \\phi(x) + \\lambda^{T}f(x,u) + \\mu^{T}C(x,u)\n\\end{equation}\n","styles":"text-center"},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Which"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"f(x,u) = \\begin{bmatrix} u_{1}*\\cos{(\\phi)} \\\\ u_{1}*\\sin{(\\phi)} \\\\ u_{2} \\end{bmatrix}","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"C(x,u) = \\begin{bmatrix} \\left(u_{1}+\\frac{u_{1max}+u_{1min}}{2}\\right)^{2}+u_{1dummy}^{2}-(\\frac{u_{1max}-u_{1min}}{2})^{2} \\\\\n          \\left(u_{2}+\\frac{u_{2max}+u_{2min}}{2}\\right)^{2}+u_{2dummy}^{2}-(\\frac{u_{2max}-u_{2min}}{2})^{2}\n\\end{bmatrix}","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"\\phi(x) = (x_{N-1}x_{N-1,ref})^{T}Q(x_{N-1}x_{N-1,ref})","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":"\\lambda = \\begin{bmatrix} \\lambda_{1} & \\lambda_{2} & \\lambda_{3} \\end{bmatrix}","styles":"inline-flex"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"math-render","props":{"latex-express":" \\mu = \\begin{bmatrix} \\mu_{1} & \\mu_{2} \\end{bmatrix}","styles":"inline-flex"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Subtitute all of these term into HJBE"}]},{"type":"element","tag":"math-render-b","props":{"latex-express":"\n\\begin{align*}\nH(x,u,\\lambda,\\mu) &= \\sum_{k=0}^{N-1}(x_{k}-x_{k,ref})^{T}Q(x_{k}-x_{k,ref}) + (u_{k}-u_{k,ref})^{T}R(u_{k}-u_{k,ref})\n                     + (x_{N-1}-x_{N-1,ref})^{T}Q(x_{N-1}-x_{N-1,ref}) \\\\ & + \\begin{bmatrix} \\lambda_{1} \\\\ \\lambda_{2} \\\\ \\lambda_{3} \\end{bmatrix}^{T} \\begin{bmatrix} u_{1}*\\cos(\\phi) \\\\ u_{1}*\\sin(\\phi) \\\\ u_{2} \\end{bmatrix}\n                     + \\begin{bmatrix} \\mu_{1} \\\\ \\mu_{2} \\end{bmatrix}^{T} \\begin{bmatrix} \\left(u_{1}+\\frac{u_{1max}+u_{1min}}{2}\\right)^{2}+u_{1dummy}^{2}-(\\frac{u_{1max}-u_{1min}}{2})^{2} \\\\\n            \\left(u_{2}+\\frac{u_{2max}+u_{2min}}{2}\\right)^{2}+u_{2dummy}^{2}-(\\frac{u_{2max}-u_{2min}}{2})^{2} \n\\end{bmatrix}\n\\end{align*}","styles":"text-center"},"children":[]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"the-optimal-control-theory-in-control-system","depth":2,"text":"The Optimal Control Theory in Control System","children":[{"id":"what-is-model-predictive-control","depth":3,"text":"What is Model Predictive Control ?"},{"id":"hamilton-jacobian-bellman-equation-hjbe","depth":3,"text":"Hamilton Jacobian Bellman Equation (HJBE)"},{"id":"continuation","depth":3,"text":"Continuation"},{"id":"generalized-minimal-residue-method-gmres","depth":3,"text":"Generalized Minimal Residue Method (GMRES)"}]}]}},"_type":"markdown","_id":"content:topics:robotics:nmpc-cgmres.md","_source":"content","_file":"topics/robotics/nmpc-cgmres.md","_extension":"md"}